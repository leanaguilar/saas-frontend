module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = (function () { try { return require('path') } catch (e) {}}()) || {
  sep: '/'
}
minimatch.sep = path.sep

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = require('brace-expansion')

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  b = b || {}
  var t = {}
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch
  }

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }
  m.Minimatch.defaults = function defaults (options) {
    return orig.defaults(ext(def, options)).Minimatch
  }

  m.filter = function filter (pattern, options) {
    return orig.filter(pattern, ext(def, options))
  }

  m.defaults = function defaults (options) {
    return orig.defaults(ext(def, options))
  }

  m.makeRe = function makeRe (pattern, options) {
    return orig.makeRe(pattern, ext(def, options))
  }

  m.braceExpand = function braceExpand (pattern, options) {
    return orig.braceExpand(pattern, ext(def, options))
  }

  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  assertValidPattern(pattern)

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  assertValidPattern(pattern)

  if (!options) options = {}

  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (!options.allowWindowsEscape && path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false
  this.partial = !!options.partial

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  assertValidPattern(pattern)

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

var MAX_PATTERN_LENGTH = 1024 * 64
var assertValidPattern = function (pattern) {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern')
  }

  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long')
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  assertValidPattern(pattern)

  var options = this.options

  // shortcuts
  if (pattern === '**') {
    if (!options.noglobstar)
      return GLOBSTAR
    else
      pattern = '*'
  }
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      /* istanbul ignore next */
      case '/': {
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false
      }

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        // split where the last [ was, make sure we don't have
        // an invalid re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it's tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i)
        try {
          RegExp('[' + cs + ']')
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE)
          re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
          hasMagic = hasMagic || sp[1]
          inClass = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '[': case '.': case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) /* istanbul ignore next - should be impossible */ {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) /* istanbul ignore next - should be impossible */ {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = function match (f, partial) {
  if (typeof partial === 'undefined') partial = this.partial
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned intÙÕù ¡c×   \É        €                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        t¸Å ¿y2~ğ~±~q~.}ï}´}o}0|²|c|"{1zñxàx¡xUxwÅw‰vív vNvuÒu’utÃt~t@tsÅs‚sEs
rÌr†rCrqÄq†qAqpvp6oóo¯ooo+nón³n]nm×mŸmXmlÕl–lVlkÕk•kTkjÈj‘jLj
iÌi“iWi h¼hzh9fôf´fif+e†eFdşd¤dJdcÈccPcbÒbƒbDbaÈa„aEa `Ç`Œ`D`_Å_ƒ_'^ç^¬^g^&]ã]ª]g]"\¥\b\&[á[§[_[ZÛZdZ(Y©YfY)XíXªXlX'WåW§WiW-VïV7UıU»U}UCUTÅT‚T9SÃS‚SBSRÄRRAQ£QaQPÉP*OçO©OkONŞNŸN^NM‡MIMLÌL@LKÂK€K'JåJ˜J=I÷IHmH%GãG©GoG0FîF¢FaF&EëEªEkE*D}DBDC½CqC7BøB¸BsB,AèA©AoA0@ñ@´@k@3?ê?§?v?&>”>Y>=Ú=–=T=<×<”<I<;À;‚;C; :¼:s:9: 9Á9x968ı8º8i837í7­7b76Ü6Ÿ6]6"5Ó5‡544ö4µ4s403ì3“3N32Ê2‡2E21É1ˆ1N0ù0»0x09/ó/´/[/.È.€.D.-§-f-$,ã,¤,c,)+ê+ª+h+&*ë*•*S*)Ü)–)O(•(N('À'€'8&ù&§&n%ë%%M%$Í$Œ$N$#²#t#3"ù"¯"q"(!ï!«!m!, é ¤ ] Ö—Rÿ¿v8ô±p1Ü™ZÍTÏF»ƒAü½%}×¢f-ï–HÆ„FÈ†OÚ_!ã¡_!Ş–_Û•RØ™\'éœf'ë²p5ù³_ Ó›W
Ş

L
		±	t	5ÙƒFÅ‰Bí°u7ú¿Cü¹t:şÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅÅ                       5¡u --	https://glif.appstorageAccessAPI“IV’aIîV8¡t 3-	https://ai.meta.comstorageAccessAPI“IÖ¾’aGª¾6¡s /-	https://arxiv.orgstorageAccessAPI“I˜ª’aGlªA¡r E-	https://python.langcha                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      İc¶Î¢d¯"÷êá•;Ÿ±'ÇdM_5N†ÃVŸó…[^—3©o«hÿÚ˜±OUª‰Ê·~AZxã”a®äÚëj¹Ÿ}{•Ÿ}·ú±šÄYûŠ¯Zçi×şWk÷¿¶Õó®øŸLø[›Iª†BŞ]»…yÉX¿g—Ó[ûÓÎí¿»h¤•_7©òìs¹*“»â$[
N}Gyşİ¥ê£¬ÉÙX©Ì¿EÍI¸Àş†OÎÎ–ıÑ6¼›q*(óôs¦¶<¨QÂE¿:K}KYï—Ãûï£Jä¬m¯ÊF¥Åİúw¿¾­”ü;›Ó]]–§'Y}ĞM×™²öÎdéÔ×MƒxÊµ_³) ÿ8“ünò¹k÷¹;èú­ı(÷cÖpèïÅ™ê< XMà…B^db7Œ†~çCAk•28/[Î“ßVvA³;ö0èÜ‰şìÑ‹!Ğ¿–=1Îb_–·ÅY(ÙŸÛÎÑ9ÎY½òî«/;G'ì\Dßê5BëŞ3×pW
Nã­z½z“—ÿé5*Ë-÷BvbÅ~¹ÿï¯.¹<İUè¦›2:>,ûŞ–Î{	2TÒË(gw£ŠÕ>+Ã¹ªS–GdßuÊw¾|ÌxñB×»vÿ32`S?¸@fŠE_¬şhyòÛİŒœöKÑÕ¿ûeíÓ™½¬»Ë2„º%Ÿ|±Ë•t]İu4ÇM…J‰¾yS—5è´™u{mD§EéOïşÌÌÂ—Õ´Ü¼ÇjN…Oş?.(ù_ºkÜÑ®@/wC÷y»êóå·à]ı;‘ù½xwÁ™Böey;8Õmã÷Â¯»Šä×îÙ¹†’ÎOt–Ç•¸RĞ»8õêM^ş§W¿lò‰,`×ıDÇı¢óÿÛ«K2õiÒ 7uù›Ñî¼}d5¹òø<‘Ä3äu9©¯ØIû÷‘¼;O_ª	PûbÒP5Q]çì·ëaòíú,5Yıˆ7©›±iÓI£Õ5S}W¾c•ïØÊwìqêaõ;5^=¥æ=ÍWÏGıY­¢¿ı}·|Çş|Ç~V¾cÏ“ïØÿO¾cÏ—ïØÿ!ß±ÿ,ß±ÊwìÅê=Z=/_­ÊWë¨ıj­Rö«µj±_ªÕgöKµJÛ/Õ´®ÔëT›|…öËWèğëÀ xœµW{L×Uÿ|~ÀOF¨<Œ~‘½‰•:ç´‡2%BsÌQñ33s­9çœóæZëA[c¶Ì
Ê½_ö2EPQ+óÚj­?¬Ï½ßK<DùY¶ßÎ9÷Ü{Î=ç{ï¹çœ š‹|Íğİ>1·±%µ•‹pÍã¯¿0P„?bĞ— —"´6ñH@"²9¡è Šo›PhpÁ“'°4ojn MSó8PhW&kwdw÷õ¹ètîÚ!Ùïd#/@6êd£Ï)›TRRQ‹e¥%Áûğtiéœj<[V1û~Ô—UVÍACyMI)Vk¢ŸTT•V`›ÅÛ-nµx_eİœ¬ª)«Ä±j184{şœ]Y3Á`ÆH†g2Zø&Æ	g11X7+È”`]uiµÒbº<öY¯Œp7cpºÅı…Í7\*ÿÉ÷$\†Ë1WàJ\e%®µ8Âb¿Åı,´8Æâ«-fñugˆ×Ë
qƒVˆ1Tx¸]²8ÚâkœsB”gÃH”¡µXˆÅX•xXƒ&4ã#lÃìÅAœÀï8C?c™ÈTãpŞÌqœÈ)œÎ{XÎJÎåB.ær®älà6±™qwp/:“Ku—Æl¶ı2ŸïHX¬·–éèXG':šãèLG+­qt¾£®ñÎ,¬Éã#¶{|D‹ãO;şO÷<ŞŸîø"ÇÏr|½ãW9Şéû~¿|ï7Ãñë¿Õã#3<>r”ã¿Şã£Æ{|T¶ã+lÎ`T­ã;ºÜÍ¯tôï$£İeFñhL†£îübÜ¹Å;Z©h,Ã¾Ávîb+¹–or[ø#÷ñ óşÌŸ¸Ÿ¹›GÙÆ#º¿ãÜÃcºñ[8Š¿ğñOóWşÆß»¿CV<'ÛÈOG¦2à8ÜŠlä`Âsx^±õ"êñ6b¶ »ĞŠ6ìÆEY;ã8€ñLâeÉÑÌã,à]\Ï÷¸O›¸™[¸•ïËÂ³z)²’…ñÈÅ}U5`	F„4áŠ½jßã<~È¯0Wã|T1ù5ª4ŞÈùü˜ßÀÈ4ó1~Âoù°Æ›¸€Ÿò;Öh¼™ó3ngPã-ŠïÏù=k5ŞÊ'ø…"»Nã÷¹ˆ_r'çÂ'ŸOê|}:“dvôæì=éŒhÏâMFÈÁdaò6N±sF&^3)öÕB·Ü!%Ê|ŞÕEÚ§]}8Ì1]vê9£ÜÁû…)Î§Œîno´fÂİ9'œg¥«¾—ûŞwi”Šş:Û¹:Çj>ÌYË:e E”­CÜXı¢ãtSf]ö0üÚn{Æ)~†	L¶n-ÇÙ³Œ³t€==3gp’òİå¬%xYYª'©¬”ÅlÎT&ZÄ¬WÚ ;İ®è=díŸıóÙ“†Ë«½K¨®÷¡Ùû:”sÏ§ÕÛ*”ãÏ­qöTÎ%İsÊ3½Kú{ÈEô*ÑM&¼‰ğ.ëag­†ı³æë±âCG…ì:Û1×ùL­ğó^xqĞù®Rìj\·è"«Ğ3æ:_Y*¼|?°[RcgÚ‰¢ÕÚ,«ß«~h;Ö‰¥©Vß¬üeöJìc¯ĞvMÖMÕû¥¼›k÷ò¾¡YHQÄÓûƒÛõ½º—ü/l„f-U‘ìU’‰ÈG‘²¼±—òŸì…f9 gîyœêWf¢\•ÂØN½H¶Có"M™Â‹‘â<€U9ãGà¢ûšGC•ñ:âk:Šñ í—XŸÒşGŸúöÎËŞ?ÈÏ®¾øX%¨+øÒæîÕÇd/Ã†óIí”¯şÜH0’gî¶¶×«ëğêÖ+İ4‡Ûêou›4.’~¤rU<ß5ßÆ·m]6Ym’z!*ªŒ=¿äQCi|]š“Ç5–æğ-«ùšpW}¾jõg¯Óÿ†ñz…Ùº‰|EÇEi±^ÈªŒÕº•yŠ”ExJw³+Ô=£¬^sVã}‘vA£`­`@}2ìü øYğ“`¿@İ<w
Úê=¹Wp\°GpLpRğ‹à„àà”à´|b_³é	Cë:»A}{:¨sm<G·Ú¦Z¿ÇXÓİ¤ËFïû·jï½i;‹u¿GÕá7>+sfËz›,·»Õu<iûİSvušóf´‚×ì=dJ²?Â\/¬:çõ¬èÑ3ıÚíü­   xœc`a²aÚÃÀÊÀÀÔÅÁÀÀà¡ãŒu@ƒ;b„ñ=CÜü2(üfaşô_€!…ùÃ†É 9ÆwL·€ BÀ­xœÍÓIpTEÇñïÿ½É#IBÇ‡3	†…@!€*	!&,!  ”¥HX´Ô˜‚°‚Êš 8a•8iQÖ›ÇÍ£zĞÂÊkÚ@YÜ½Ø]İÿêêË§ºÀæîÊEÌUeNÒwXù¦n!NĞÌ§›2Tb2J
¥ZfÊ2Ù m¢­«ĞúÁúÅØ©v;ÃÎ³ÇÙìãöåPKè5Pe«rTTT£U±ªPUj¥zKmWİáÁa'\®ïq,'è¤;N¶rbNµSç4FENG®F®Eò2ÿÒ´6Å!ºø‚o$*2VŠdºÌ–ÆqÛÊ2+Öu;h§GÔ8
ûñĞï*Se©\¥î9Šî9Ö¨¸qêsÌ·GŠq¸ÏÑéŒôD~ü×ÖÚÓ—ô÷ú;ı­¾¨Ïësú¬>£{ô)İ¡Çë¶ıµ~£_éWøå~©?ÌÏõsz»zwŞúùV“7Ã«ö¦zS¼J¯Ø+òÆxÃ½˜G²7ùgò§ds²>97so»mn«»ÍİêÆİõî*·Æ-sKnJâ·D"q=ñööÔ®`×İÿúŒ •öOş³H°Lú¤˜¼õ#•HãAúó“Î# ƒLò(ƒLCÈ&Ç$õ1B<n’Æa(O!JùãIbç)
ÁHF1š1Œeã)dESB))c“)§‚Jªxš)L¥šiLgÏ0“g™Ålãy^`5¼È\^âe^a¯2ŸZœ¼GÒÆn:ØÏ:9hû‡ùœ#5]tŒ&Á'ùÒ¤ø=|Å9Îò5çeËYH=‹d	o°e,‘Í¬b±`;d+ä tÒÀjÙ!»e—ÔÈş¾‡›Ã§œáêh’½2B:¤¥¼)KÍå:Şå	HŠÔÊyM¤NrZ›Ê—×e£4Ëré–“²˜5R/Òdº}ëÙÊf¶ó>°i•|D;»ØÉ¯R"å4ËD)“I¬•
™,¥w ñ¬í#   xœc`d```b`ÈLß/Ïoó•›ùP„á®„GŒşÏóŸ­‰Å™¤– .÷
›   xœc`d``şô_€!…]è?Ï¿×lM)H€ñ Ÿnl xœUmL–e¾Î¹!Ò1'‚ €)`ÄGâìE>L”)„
ÃŠ6èÃf?×ŒD¦-œ?d¡sZ®¯•K×V¶57k+óGsXs‹Ñü‘³ÍÆœ-ï®óğ¾Hf?®]ï}¿ç¹Ÿs®û:ç‘	Ê@BX)Ÿ£]¿C†V"ÑDşŒeC»äâQÉógd[´;%©rkd	–É!?¬_¢Xà9-ÇCšxíÄ\­E–îÆrMD…¶ñÌİ¨’•È#áÕD%ñ¸.E•;Õú®¿¢İÈÑk(ÖßÈUD>rœãz9|W.FŸÉÑî·¯’cğÏŸä>î1wæQ­ˆØáÆ±“gÿ¡¯ã­ğ·XKœBäú!ùš„(Y€MA’¾€dMEš61ß¤Éfdjƒ¿­HÆ8qİï×8¤à&RÜ‹Œ]Gl²x?Ág3¤Éòb¤šÏ…§s‘çæPßqÖæüyò^¶S·¬—z‘µl1İµ !íâgQ =Ø*O£R†yŞÇ8ê²QÄZV0v£L ^öãˆ¬Æ6®ó¥‰º´ø¿$òcZÇ˜(çGp—¹]€èqÄê9â<
YÓ¢@çûÀó—í«ÂÚ‡aºOï&5¢ûL0§íä…öSaÚ·òÙÌÉt¾ÜKdÓ>c:İ'±Ğ˜9¥ßÓ}&ú±ƒ</Ğ~*¨}pGÆV¯½s&[íöşÙØ<i¾°úMËñø—šÍÛæ/Ó–õE‡™kã~4²6ïş3ÿÓƒÖæÃIöw¦®eoÀó¹N°»
ôš…ƒ{£vªç]fşì%óó$û[÷Öì/óø¬ÌŞ£ÿÓÃœæ¥ì.ÀÖ¯Ö3gì¾"}ËŞù·øk‘û3ÿš‡ÿ™¦ç“iÚI:‰>ùïãwdöbÔËIì“¯Ñ!qxr;ã>ä^{m€±—;ˆ£²½œ‘²}ÂÛ¸è¯â®ÑRöq4–èbŞÃ[Ôh²"uÌäH]î,Ê¢>@{·h'’ØómD;‘ÄwUùò)JÜ<,‹Ş„:|ƒ—å[¬ ÄF<øXùN:ıy•s !ÖÔÀûºÁß[å8Ü¦—šè£çùãš-ÎßdÜ>gq±œ]	Qò~¯sæ¿‰&·€ü÷ï0ïx”ë÷şw	ë\ˆÿ]Bµ+B(êîâ5w½nÒİì%7³öÆÅè)<¬_Ñc« öÍĞŸíZ9¿ğ7lî…ç¾ÁÂ çøİù‘ó{jÜAÔF ïayÌ|¼Cm3u}à©L×Mt@qĞÖ“i~XùÿÜŒ¼8Ìß%ä~~cú9gû9oû±–H!"Š‰ğş³²‹}ó+5+ô·%‹óºŒz­e_–SçEÔ¬Œß‹
ò.T3®N
±J²ğ$÷sWÎ¸RÆÕr]Æ¸ZmÄfŒ ›Ëu¬ç,ïÿÖ6Ò@°Ö´HšéÛtC‰´rF%ûAóí¿ÓÏÂe   P ø  xœUÏo[Eg'v"'=PT!PÅ ¡æ’Ø%)mq•S©b*õ¸õ[?¯ú¼kínêñ€Ä‚Ä…Îœ'Î'N 'ÎÌÇİ8("«x¿İ™ov~ì€÷³ï!ƒÙßGğ…àêğ“à
4àwÁU¸uoÀÍì¥àMØÍ¾\ƒ7²W‚ëĞ©|&xnV¾¼;•_7àvuOğ¼WıJğ.ü¹9Ç7àšèÒÏ»uáÍ2hÔ÷“Ÿõ-ÁUhÔ~#o³mZ~Î'œ‘¥Wàü"¸
Gğà¸“}*xŞÎ¾\ãXÍpòì/Á[p§ò¥àmx«ò£àUş¼÷ªŸŞÍ^U¿|>¨½œarüãú‡‚3¸US0ùYû[p•ğÏpŒa
0„hÃ!Ü…FÂ§`!'E3B4Æ 	uIÿœÏ<í5içJ¸d1ğJÓ¬i~A¿9IÂ}7zS#vÚ‡w:íÎ!ÚÜ(‹½éXc×ÛÜO›xR–È‚½Ú¿Ğ9©Ÿ‘/‘ØqZªèÂÀ=Ú+‰!ùI¦¤Ó>m»2ÇÓ¨JC‹ñ·y“TnñˆĞªÅƒ…¥;f»İ>>íuåA2=·¼j¯òFTqÅ«'Ÿ@£|á%<Ñ>g‘Ù_g¹ÂÓë¸g89Šş#Q+2¡aD³‡ç´ç`À'CNõuK`q9Paô*×#åŸ£`êµ)†k‡5Ê HÒòuNh.h(¾<ĞÖà‰-
åi•J1’Ù@Ú¢a–(£^»KŸÖ#RqZ-Ãô‘Øâyß.[ğhş†ÉdÒ¼‚¥Ç9Ë­zÆ9ŠÄ¦¸ÅæÓÊÑ¾&û‘…5•ÒœXSKF.dsÖ·¬áiV|ê•WÔÈ\¯¿æ!)étÂÂS¾u’.ØOÍÖóåœ¾Ä4 ıåzK‰1+ÏÈ3–HşŒXæ‚İó-ó®ZØcMGXi°Çñ¥ú¾|»ğŸ÷­™Ì”£ª¹}ŞuéY&rº}ÍUCê™Şº¥ëlÄ37ˆåujŸ±wQ÷£Î‘ê@{ÌİH‡hú¨lÆFí­Šô.¨r©ÏÒYñ¶–jÒÄ§îUáµÆèĞäÚF3˜Îº±×ÅÑ|6E«Fz¦îunâ\`/ ›Xz†f<ïâ]XåäíL1×ÁO—ÈÏûÉM±š—[æ"ÉC)åyk´¤Gt¶hvyHQJ­Ñ¢8Œè0}y–K7%õ1m—³8i|¼^&.ËÄõ2Å²L±^æ!ìs1ìË÷®àfœIÍZp^K¶î£Ú§ïZamQ¦SØà_:Gé^xœc`f`øÿˆm°  Za†   